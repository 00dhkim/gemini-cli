# CSU-03.02.02: 내용 검색(Grep)

## 1. CSU 간단 설명

`tools/grep.ts`에 위치한 이 CSU는 모델(LLM)이 파일 내용에서 특정 텍스트 패턴을 검색할 수 있도록 하는 `search_file_content` 도구를 구현합니다. 이 도구는 정규식(regex)을 사용하여 강력한 패턴 검색을 지원하며, 검색 결과를 `파일경로:줄번호:내용` 형식으로 구조화하여 반환합니다.

이 도구의 핵심적인 특징은 사용자의 환경에 맞춰 가장 효율적인 검색 전략을 자동으로 선택하는 다중 전략(multi-strategy) 접근 방식입니다. `git grep`, 시스템 `grep`, 순수 JavaScript 구현 순으로 우선순위를 두어 최상의 성능을 보장합니다.

## 2. CSU를 구성하는 변수와 함수 목록

### 주요 클래스

| 클래스명             | 설명                                                                                     |
| -------------------- | ---------------------------------------------------------------------------------------- |
| `GrepTool`           | `search_file_content` 도구의 정의(이름, 설명, 파라미터 스키마)를 담당하는 클래스입니다.  |
| `GrepToolInvocation` | `search_file_content` 도구가 실제로 호출되었을 때, 그 실행 로직을 담당하는 클래스입니다. |

## 3. 각 클래스에 대한 입출력 및 함수 처리 설명

### 3.1 `GrepTool` 클래스

- **역할**: 모델에게 `search_file_content` 도구의 사용법을 알려주는 명세(specification)를 정의합니다.
- **주요 로직**:
  - **`constructor()`**: 도구의 이름(`search_file_content`), 설명, 그리고 파라미터(`pattern`, `path`, `include`)의 JSON 스키마를 설정합니다.
  - **`validateToolParamValues(params)`**: 모델이 전달한 파라미터의 유효성을 검증합니다.
    - `pattern`이 유효한 정규식인지 확인합니다.
    - `path`가 지정된 경우, 해당 경로가 허용된 작업 공간(workspace) 내에 있는지 확인하여 보안을 강화합니다.
  - **`createInvocation(params)`**: 파라미터 유효성 검증이 끝나면, 실제 실행 로직을 담고 있는 `GrepToolInvocation` 인스턴스를 생성하여 반환합니다.

### 3.2 `GrepToolInvocation` 클래스

- **역할**: `search_file_content` 도구의 한 번의 호출에 대한 실제 실행을 담당하며, 최적의 검색 전략을 선택하고 실행합니다.

#### `execute()` 메서드

- **입력**: 없음 (필요한 파라미터는 생성자에서 `this.params`로 전달받음)
- **출력**: `Promise<ToolResult>` (검색 결과를 포함한 객체)
- **함수 처리 설명**: 1. **검색 디렉터리 결정**: `this.params.path` 유무에 따라 검색 범위를 특정 디렉터리 또는 전체 작업 공간으로 결정합니다. 2. **검색 위임**: `performGrepSearch()` 메서드를 호출하여 실제 검색을 수행하고 결과를 수집합니다. 3. **결과 포맷팅**: 검색된 결과가 없으면 "No matches found" 메시지를 반환합니다. 결과가 있으면, 파일 경로별로 그룹화하고, 모델이 이해하기 쉬운 형식(`File: ...
L...: ...`)으로 `llmContent`를 생성하여 `ToolResult` 객체로 반환합니다.

#### `performGrepSearch()` (내부 헬퍼 메서드)

- **역할**: 우선순위에 따라 여러 검색 전략 중 하나를 선택하여 실행하는 핵심 로직입니다.
- **함수 처리 설명 (전략 우선순위)**:
  1.  **전략 1: `git grep`**
      - 현재 경로가 Git 리포지토리이고, 시스템에 `git` 명령어가 설치되어 있으면 `git grep`을 최우선으로 사용합니다.
      - `git grep`은 `.gitignore`를 자동으로 존중하고 C로 구현되어 있어 매우 빠릅니다.
      - 실행 결과(stdout)를 `parseGrepOutput`으로 파싱하여 반환합니다. 실패 시 다음 전략으로 넘어갑니다.

  2.  **전략 2: 시스템 `grep`**
      - `git grep`을 사용할 수 없을 때, 시스템에 `grep` 명령어가 설치되어 있는지 확인하고 사용합니다.
      - `grep -r -n ...` (재귀적, 줄 번호 표시) 형태로 실행하며, `config`에 설정된 제외 디렉터리(`--exclude-dir`)를 적용하려고 시도합니다.
      - 실행 결과를 파싱하여 반환합니다. 실패 시 다음 전략으로 넘어갑니다.

  3.  **전략 3: 순수 JavaScript 대체(Fallback) 구현**
      - 위 두 네이티브 명령어를 모두 사용할 수 없을 때 실행되는 가장 기본적인 방법입니다.
      - `globStream`으로 검색 범위 내의 모든 파일을 찾고 (`.gitignore` 등 존중), 각 파일을 `fsPromises.readFile`로 읽어와 한 줄씩 정규식으로 매칭하는 작업을 수행합니다.
      - 가장 느리지만, 어떤 환경에서든 항상 동작하는 것을 보장합니다.

## 4. 기타 참고사항

- **성능 최적화**: 이 도구는 가장 빠른 `git grep`부터 가장 느린 JS 구현까지, 점진적으로 저하(graceful degradation)되는 검색 전략을 통해 어떤 사용자 환경에서든 최적의 성능을 제공하도록 설계되었습니다.
- **출력 파싱**: `parseGrepOutput` 헬퍼 함수는 `git grep`과 시스템 `grep`이 공통적으로 생성하는 `파일경로:줄번호:내용` 형식의 출력을 안정적으로 파싱하여 구조화된 데이터로 변환하는 역할을 합니다.
