# CSU-03.04.01: 정보 저장(Memory)

## 1. CSU 간단 설명

`tools/memoryTool.ts`에 위치한 이 CSU는 모델(LLM)이 사용자와의 대화에서 중요한 정보를 영구적으로 저장할 수 있도록 하는 `save_memory` 도구를 구현합니다. 이 도구는 사용자가 명시적으로 기억해달라고 요청한 사실(fact)이나, 에이전트가 앞으로의 상호작용을 위해 중요하다고 판단한 정보를 사용자의 전역 설정 디렉터리(일반적으로 `~/.gemini/`)에 있는 `GEMINI.md` 파일에 추가합니다.

이를 통해 에이전트는 단일 대화 세션을 넘어 지속되는 장기 기억을 가질 수 있습니다. 파일에 직접 내용을 추가하는 민감한 작업이므로, 다른 파일 수정 도구와 마찬가지로 사용자에게 변경점을 `diff`로 보여주고 승인을 받는 안전장치를 갖추고 있습니다.

## 2. CSU를 구성하는 변수와 함수 목록

### 주요 클래스

| 클래스명               | 설명                                                                             |
| ---------------------- | -------------------------------------------------------------------------------- |
| `MemoryTool`           | `save_memory` 도구의 정의(이름, 설명, 파라미터 스키마)를 담당하는 클래스입니다.  |
| `MemoryToolInvocation` | `save_memory` 도구가 실제로 호출되었을 때, 그 실행 로직을 담당하는 클래스입니다. |

### 주요 함수

| 함수명                    | 설명                                                                               |
| ------------------------- | ---------------------------------------------------------------------------------- |
| `computeNewContent`       | 현재 메모리 파일 내용에 새로운 `fact`를 추가했을 때의 최종 파일 내용을 계산합니다. |
| `getGlobalMemoryFilePath` | 전역 `GEMINI.md` 파일의 절대 경로를 반환합니다.                                    |

## 3. 각 클래스 및 함수에 대한 상세 설명

### 3.1 `MemoryTool` 클래스

- **역할**: 모델에게 `save_memory` 도구의 사용법과 적절한 사용 시나리오를 알려주는 명세(specification)를 정의합니다.
- **주요 로직**:
  - **`constructor()`**: 도구의 이름(`save_memory`)과 함께, 모델을 위한 매우 상세한 설명을 설정합니다. 이 설명에는 언제 이 도구를 사용해야 하는지(예: "고양이 이름이 Whiskers라고 기억해줘"), 그리고 언제 사용하지 말아야 하는지(예: 현재 대화에만 관련된 임시 정보)에 대한 명확한 가이드라인과 예시가 포함됩니다.
  - **`validateToolParamValues(params)`**: 모델이 전달한 `fact` 파라미터가 비어있지 않은지 검증합니다.
  - **`createInvocation(params)`**: 파라미터 유효성 검증이 끝나면, 실제 실행 로직을 담고 있는 `MemoryToolInvocation` 인스턴스를 생성하여 반환합니다.

### 3.2 `MemoryToolInvocation` 클래스

- **역할**: `save_memory` 도구의 한 번의 호출에 대한 실제 실행을 담당하며, 사용자 확인 및 파일 쓰기 로직을 관리합니다.

#### `shouldConfirmExecute()` 메서드

- **역할**: `execute()`가 호출되기 전, 사용자에게 메모리 파일 수정을 허용할지 확인하는 절차를 수행합니다.
- **함수 처리 설명**:
  1.  `readMemoryFileContent()`를 통해 현재 `GEMINI.md` 파일의 내용을 읽습니다.
  2.  `computeNewContent()`를 호출하여, 새로운 `fact`가 추가된 후의 파일 내용을 미리 계산합니다.
  3.  기존 내용과 새로 계산된 내용의 차이점을 보여주는 `diff` 패치를 생성합니다.
  4.  UI가 사용자 확인 다이얼로그를 렌더링하는 데 필요한 정보(`ToolEditConfirmationDetails` 객체)를 반환합니다. 이 객체에는 `diff` 내용과 함께, 사용자가 "항상 허용"을 선택했을 때 이를 기억하는 콜백 함수가 포함됩니다.

#### `execute()` 메서드

- **역할**: (사용자 확인 후) 실제 `GEMINI.md` 파일에 새로운 `fact`를 쓰는 작업을 수행합니다.
- **함수 처리 설명**:
  1.  사용자가 확인 창에서 직접 내용을 수정했는지(`modified_by_user`) 확인합니다. 만약 그렇다면, 사용자가 수정한 `modified_content`를 파일에 그대로 덮어씁니다.
  2.  사용자가 내용을 수정하지 않고 제안된 변경을 승인했다면, `MemoryTool.performAddMemoryEntry()`를 호출하여 표준 추가 로직을 수행합니다.
  3.  `performAddMemoryEntry`는 `computeNewContent`를 통해 최종 파일 내용을 계산하고 `fs.writeFile`으로 파일에 씁니다.
  4.  작업 완료 후, 모델과 UI에 전달할 성공 메시지를 담은 `ToolResult` 객체를 반환합니다.

### 3.3 `computeNewContent()` 함수

- **역할**: 메모리 파일(`GEMINI.md`)을 체계적으로 관리하는 핵심 로직입니다.
- **함수 처리 설명**:
  - **헤더 검색**: 현재 파일 내용에서 `## Gemini Added Memories`라는 헤더를 찾습니다.
  - **헤더가 없을 경우**: 파일 끝에 헤더를 새로 추가하고, 그 아래에 `- {fact}` 형식으로 새로운 메모리 항목을 추가합니다.
  - **헤더가 있을 경우**: 해당 헤더 섹션의 끝을 찾아, 그 바로 위에 새로운 메모리 항목을 `- {fact}` 형식의 리스트 아이템으로 추가합니다. 이를 통해 모든 메모리가 지정된 섹션 아래에 깔끔하게 정리됩니다.

## 4. 기타 참고사항

- **인간이 읽을 수 있는 메모리**: 이 도구는 복잡한 데이터베이스나 벡터 저장소 대신, 사용자가 언제든지 직접 열어보고 수정할 수 있는 간단한 마크다운 파일을 사용합니다. 이는 투명성과 사용자 제어권을 높여줍니다.
- **안전성**: 다른 파일 수정 도구와 동일한 `ToolEditConfirmationDetails` 메커니즘을 재사용하여, 사용자가 자신의 "장기 기억"에 어떤 내용이 추가되는지 명확히 인지하고 제어할 수 있도록 보장합니다.
