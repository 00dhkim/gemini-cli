# CSU-01.03.02: 설정 파일 관리

## 1. CSU 간단 설명

`config/` 디렉터리에 위치한 이 CSU는 Gemini CLI의 모든 설정을 관리하는 중추적인 역할을 합니다. 설정의 생명주기 전체, 즉 스키마 정의, 여러 소스(사용자, 워크스페이스, 시스템)로부터 `settings.json` 파일 로딩, 설정 값 병합, 그리고 최종적으로 애플리케이션의 동작을 제어하는 `Config` 객체 생성을 담당합니다.

## 2. CSU를 구성하는 변수와 함수 목록

### 주요 파일 및 역할

| 파일명              | 설명                                                                                                       |
| ------------------- | ---------------------------------------------------------------------------------------------------------- |
| `settingsSchema.ts` | `settings.json` 파일의 유효한 구조, 타입, 기본값을 정의하는 스키마(Schema)를 제공합니다.                   |
| `settings.ts`       | 여러 위치에 있는 `settings.json` 파일을 실제로 읽고, 파싱하며, 우선순위에 따라 병합하는 로직을 포함합니다. |
| `config.ts`         | 병합된 설정을 기반으로 애플리케이션의 모든 동작을 제어하는 최종 `Config` 객체를 생성하고 적용합니다.       |

## 3. 각 구성요소에 대한 입출력 및 함수 처리 설명

### 3.1 `settingsSchema.ts`

- **역할**: 애플리케이션의 모든 설정 항목에 대한 "설계도"를 정의합니다. 이를 통해 설정 값의 일관성과 유효성을 보장합니다.
- **주요 출력**: `SETTINGS_SCHEMA` 객체
- **처리 및 출력**:
  - `SETTINGS_SCHEMA`라는 거대한 상수 객체를 정의하고 export 합니다.
  - 각 설정 항목에 대해 다음과 같은 메타데이터를 정의합니다:
    - `type`: 설정 값의 타입 (`string`, `boolean`, `object` 등)
    - `label`, `description`: UI에 표시될 이름과 설명
    - `default`: 설정이 없을 경우 사용될 기본값
    - `requiresRestart`: 변경 시 애플리케이션 재시작 필요 여부
    - `mergeStrategy`: 여러 설정 파일을 병합할 때 사용할 전략 (예: `REPLACE`, `CONCAT`)
    - `properties`: 중첩된 객체 구조를 정의하기 위한 하위 스키마
  - 이 스키마로부터 `Settings` TypeScript 타입을 추론하여 애플리케이션 전체에서 타입 안전성을 제공합니다.

### 3.2 `settings.ts`

- **역할**: 파일 시스템에서 `settings.json` 파일들을 찾아 읽고, 파싱하며, 정의된 우선순위에 따라 하나의 설정 객체로 병합하는 실질적인 로딩 로직을 수행합니다.
- **주요 함수**:
  - `loadSettings()`: 이 CSU의 메인 함수. 여러 범위의 설정 파일을 로드하여 `LoadedSettings` 클래스 인스턴스를 반환합니다.
  - `saveSettings()`: 변경된 설정을 다시 파일에 저장합니다.
  - `migrateSettingsToV2()`: 구버전(v1)의 플랫한 설정 구조를 신버전(v2)의 중첩된 구조로 마이그레이션합니다.
- **`loadSettings()` 함수 처리 설명**:
  1.  **설정 파일 경로 탐색**: 시스템, 사용자(`~/.gemini/`), 워크스페이스(`.gemini/`)에 위치한 `settings.json` 파일의 경로를 확인합니다.
  2.  **파일 로딩 및 파싱**: 각 경로의 파일을 읽고, 주석이 포함될 수 있는 JSON을 `strip-json-comments` 라이브러리를 사용해 안전하게 파싱합니다.
  3.  **마이그레이션**: 로드된 설정이 구버전 형식일 경우 `migrateSettingsToV2`를 호출하여 메모리상에서 신버전 구조로 변환합니다.
  4.  **환경 변수 치환**: `${VAR_NAME}` 형태의 문자열을 실제 환경 변수 값으로 치환합니다.
  5.  **병합**: `mergeSettings` 함수를 호출하여 시스템 기본값 -> 사용자 -> 워크스페이스 -> 시스템 순서의 우선순위로 설정을 병합합니다. (워크스페이스 설정은 신뢰된 폴더일 경우에만 적용됩니다.)
  6.  최종적으로 병합된 설정과 각 범위의 원본 설정을 모두 포함하는 `LoadedSettings` 객체를 생성하여 반환합니다.

### 3.3 `config.ts`

- **역할**: `settings.ts`에서 생성된 `LoadedSettings` 객체와 커맨드라인 인자(`argv`)를 입력받아, 애플리케이션의 모든 부분에 전파될 최종 `Config` 객체를 생성합니다.
- **주요 함수**: `loadCliConfig()`
- **`loadCliConfig()` 함수 처리 설명**:
  - **입력**: `settings: Settings`, `argv: CliArgs` 등
  - **출력**: `Promise<Config>`
  - **처리**:
    1.  **설정 값 해석**: `settings` 객체와 `argv` 객체에서 필요한 값을 가져옵니다. 커맨드라인 인자가 `settings.json`보다 높은 우선순위를 갖습니다. (예: `argv.model`이 있으면 `settings.model.name`을 덮어씁니다.)
    2.  **컨텍스트 로딩**: `loadHierarchicalGeminiMemory`를 호출하여 `GEMINI.md` 파일 등 주변 컨텍스트를 로드합니다.
    3.  **동적 값 결정**: `isDebugMode`, `isWorkspaceTrusted` 등 실행 시점에 결정되는 값들을 계산합니다.
    4.  **`Config` 객체 생성**: 위에서 준비된 모든 값(모델 이름, 승인 모드, 원격 측정 설정, 도구 설정 등)을 인자로 전달하여 `@google/gemini-cli-core`에 정의된 `Config` 클래스의 새 인스턴스를 생성합니다.
    5.  생성된 `Config` 객체는 애플리케이션의 다른 부분(예: `useGeminiStream` Hook)에 주입되어 일관된 동작을 보장하는 데 사용됩니다.

## 4. 기타 참고사항

- 이 세 파일은 "정의(`settingsSchema.ts`) -> 로드 및 병합(`settings.ts`) -> 적용(`config.ts`)"의 명확한 단계를 거쳐 설정을 관리합니다.
- 사용자는 여러 `settings.json` 파일을 통해 설정을 계층적으로 관리할 수 있으며, 커맨드라인 플래그를 통해 일시적으로 설정을 덮어쓸 수 있습니다.
