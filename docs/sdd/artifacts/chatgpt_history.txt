나는 국방과학연구소에서 무기체계의 소프트웨어 개발을 담당하고 있어. 무기체계의 소프트웨어 개발을 하기 위해서는 소프트웨어설계기술서(SDD)라고 불리는 문서를 작성해야만 해. 나는 소스코드에서 SDD를 생산하는 자동화 방법을 LLM 기반 에이전트를 통해 구축할거야. 너는 지금부터 SDD Agent를 구축하기 위해 나에게 도움을 주는 전문가야. 첨부된 파일은 SDD 양식 pdf 파일이야. 우선, SDD Agent 개발을 위한 타겟이 되는 무기체계 소프트웨어의 소스코드가 있으면 좋을 듯 한데, 우리 회사의 무기체계 소프트웨어가 대부분 비공개라 개발에 활용할 수 없어. 공개된 소스코드 (레포지토리 포함) 중에 SDD Agent 개발에 활용할법한 소스코드가 있을까?

좋습니다. “SDD Agent”를 만들 때는, **무기체계 SW와 유사한 제약(상태/모드, 실시간성, 통신·인터페이스, 안전/보안, 패키징, 추적성)**을 충분히 보여주는 공개 코드가 필요합니다. 아래는 실제로 SDD 목차(상태·모드, 인터페이스, CSCI/CSC/CSU, 추적표 등)로 역산해 학습·평가하기 좋은 **대표 오픈소스 코드베이스 8종**과, 각 코드가 SDD의 어느 절을 자동 생성하기 좋은지 매핑한 추천입니다. (첨부하신 SDD 양식 기준. )

---

### 1) NASA **core Flight System (cFS)** – 우주비행체용 임베디드 FSW 프레임워크

* **왜 좋은가**: 명확한 **서비스 계층(cFE/OSAL/PSP)**, 애플리케이션 단위(“앱”)의 모듈화, 명령/텔레메트리(software bus) 구조가 **CSCI→CSC/CSU**, **인터페이스(내·외부)**, **상태/모드**를 기술하기에 이상적.
* **SDD 자동화 포인트**:

  * 3.2 상태/모드, 3.8 인터페이스 결정사항(명령/텔레메트리), 4.1 구성요소 식별자, 6. 요구사항 추적(앱별 메시지 ID·테이블)
* **참조**: cFS 번들/구성 설명과 하위모듈 링크. ([GitHub][1])

### 2) **PX4 Autopilot** (+ NuttX RTOS) – 항공 임무형 상태/모드가 뚜렷한 대형 코드베이스

* **왜 좋은가**: **Flight mode**가 풍부(수십 종)하고 **uORB** 메시징, **NuttX 기반 RTOS** 통합이 잘 정리되어 있어 **상태·모드/실시간 인터페이스/리소스 계획** 섹션을 자동 산출하기 쉽습니다.
* **SDD 자동화 포인트**:

  * 3.2 상태와 모드(비행모드 일람→운용/훈련/정비 모드 매핑), 4.2 실행개념(시퀀스/상태도), 3.10 자원활용 계획(NuttX 보드/드라이버), 3.11 패키징(펌웨어 빌드/배포)
* **참조**: PX4 비행모드 문서, PX4↔NuttX 관계. ([docs.px4.io][2])

### 3) **ArduPilot** (+ MAVLink) – 인터페이스/모드/파라미터 체계가 체계적

* **왜 좋은가**: **MAVLink**를 통한 모드 제어·파라미터·로그 구조가 정형화되어 **외부 인터페이스(프로토콜/데이터요소)** 작성에 매우 적합.
* **SDD 자동화 포인트**:

  * 4.3.1.1 외부 인터페이스 목록(연동 대상·프로토콜·데이터 요소), 5.x 변수/함수 설명(자동화 도구로 파라미터 테이블·msg ID 추출)
* **참조**: Flight mode/MAVLink 제어, 코드베이스 러닝 가이드, pymavlink. ([ArduPilot.org][3])

### 4) **OpenDDS (OMG DDS/RTPS)** – 분산 미들웨어의 표준 인터페이스 규정

* **왜 좋은가**: **QoS·주제/타입 정의·RTPS** 등 **통신/프로토콜 특성**을 표준으로 기술 가능. **IDD/ICD·인터페이스 설계 결정사항** 자동 생성 템플릿에 최적.
* **SDD 자동화 포인트**:

  * 3.8 인터페이스 설계 결정사항(프로토콜/QoS), 4.3 인터페이스 구성도·목록(토픽·타입·QoS → 데이터요소 정의)
* **참조**: 프로젝트 개요, Dev Guide. ([GitHub][4])

### 5) **Cyphal/UAVCAN (libcanard, pycyphal)** – 차량/무기 플랫폼의 **CAN 버스** 계열 인터페이스

* **왜 좋은가**: **CAN/Cyphal** 메시지 스키마가 명확하고, 임베디드(C)~호스트(Python) 스택이 있어 **내·외부 인터페이스(물리/프로토콜/데이터요소)**를 실제 신호 수준으로 뽑아내기 좋음.
* **SDD 자동화 포인트**:

  * 4.3.1.2 내부 인터페이스 목록(IIC/IIP), 5.x 인터페이스 단위 설계(프레임/신호 테이블)
* **참조**: libcanard, pycyphal, 활용 사례. ([GitHub][5])

### 6) **Zephyr RTOS** – 장치드라이버/리소스/보안 설정을 문서화하기 좋은 현대 RTOS

* **왜 좋은가**: 장치 모델/서브시스템/보드 DTS 구성이 구조화되어 **자원활용 계획(보드·드라이버), 보안·설계규칙, 패키징** 자동화에 유리.
* **SDD 자동화 포인트**:

  * 3.10 자원활용 계획(보드/드라이버 표), 3.4 보안방안(권한/구성), 4.1.4 하드웨어 자원
* **참조**: 프로젝트/디바이스 모델 문서. ([GitHub][6])

### 7) **NuttX (PX4 포크 포함)** – 항공 임무형에서 검증된 POSIX 계열 RTOS

* **왜 좋은가**: POSIX 유사 API·드라이버 모델·파일시스템·스케줄링이 명확. **실시간 제약/드라이버 수명주기** 관점 문서·예제가 풍부.
* **SDD 자동화 포인트**:

  * 3.1 개발방법론/자동화도구(빌드 계통), 3.2 상태/모드 하부(드라이버 init→활성→오류)
* **참조**: PX4-NuttX 저장소, 드라이버 라이프사이클 해설. ([GitHub][7])

### 8) **GNU Radio** – 통신/레이더 DSP 체인을 “실행개념”으로 뽑기 쉬운 블록 그래프

* **왜 좋은가**: **블록·플로우그래프**가 곧 **CSU 간 실행/데이터 흐름**이며, 파이프라인을 **순서도/시퀀스/타이밍**으로 매핑하기 탁월.
* **SDD 자동화 포인트**:

  * 4.2 실행개념(데이터플로우/타이밍), 3.3 상용/오픈SW 활용방안, 3.5 메시지/오류 대처
* **참조**: 프로젝트 개요, 4.0 아키텍처 방향. ([GitHub][8])

---

## 어떤 조합으로 시작할까 (권장 로드맵)

1. **cFS(우주 FSW) + OpenDDS**: **임무 앱 구조 + 표준 미들웨어** 조합으로 “**CSCI 구조/인터페이스/상태**” SDD 절을 가장 정교하게 자동 산출. ([GitHub][1])
2. **PX4(또는 ArduPilot) + NuttX + MAVLink**: **상태/모드·실시간/센서-액추에이터** 중심의 무기체계와 유사한 런타임. **외부 인터페이스(지상국/동료 체계)** 표도 뽑기 쉬움. ([docs.px4.io][2])
3. **Zephyr(또는 NuttX) + Cyphal**: **차륜형/무인차량/탄체 전장버스** 계열을 상정한 **CAN 기반 내부 인터페이스** 표준화. ([GitHub][6])
4. **GNU Radio**(선택): 통신/레이다 처리 파이프라인을 **실행개념도/예외처리**로 유도. ([GitHub][8])

---

## “SDD Agent”가 자동으로 뽑기 쉬운 항목 (예시 매핑)

* **3.2 상태와 모드**: PX4/ArduPilot의 Flight Mode → **작전/훈련/정비 모드**로 분류 변환. ([docs.px4.io][2])
* **3.8 인터페이스 설계 결정사항**:

  * DDS(OpenDDS) 토픽/QoS/RTPS → **프로토콜·데이터요소 표**
  * MAVLink/Cyphal 메시지 → **외부/내부 인터페이스 목록** 자동 생성. ([opendds.readthedocs.io][9])
* **4.1 CSCI/CSC/CSU 구성**: cFS 앱 구조, PX4 모듈·uORB 토픽, Zephyr/NuttX 드라이버 트리 → **구성요소/식별자** 자동 부여. ([GitHub][1])
* **4.2 실행개념**: GNU Radio 플로우그래프, PX4/NuttX 드라이버 라이프사이클 → **시퀀스/타이밍/예외처리** 텍스트+다이어그램. ([GitHub][8])
* **6. 요구사항 추적**: cFS 앱/테이블 정의, MAVLink 메시지·파라미터 목록 → **요구-설계-코드 요소 링크**(ID 기반). ([GitHub][10])

---

## 다음 액션 (제가 바로 해드릴 수 있는 것)

1. **타깃 2종 선정**: 예) `cFS+OpenDDS`(우주형)와 `PX4+MAVLink+NuttX`(항공형).
2. **SDD-스키마 바인딩**: 첨부 양식의 필드(예: “4.3.1.1 외부 인터페이스 목록”, “1.3.4 식별자 규칙”)을 코드메타데이터에 매핑하는 **규칙 집합(JSON Schema)**을 작성. 
3. **리포지토리 인게스터**: AST/빌드메타/IDL(DDS)/msg(MAVLink/Cyphal) 파서로 **표/다이어그램/식별자** 자동 생성(예: Graphviz/PlantUML/Markdown+CSV).
4. **샘플 SDD 생성**: 각 타깃에서 **3·4·5장 중심** 초안 SDD를 자동 산출 → 사람이 최종 다듬는 **Human-in-the-loop** 워크플로 설정.

원하시면 위 조합들 중 **두 개**를 골라, **초기 SDD 자동생성 파이프라인**(클로저 스크립트/파서/템플릿 포함)까지 한 번에 만들어 드릴게요.

---

# 불확실성 지도

* **가장 덜 자신있는 부분**: *무기체계 고유 표준(예: 특정 국방 ICD, 보안세부)과의 정확한 1:1 매핑 범위*. 공개 레포는 민수·우주/항공 중심이라 일부 표/용어는 방산 실규격과 미세하게 다를 수 있습니다.
* **지나치게 단순화했을 수 있는 부분**: *“상태/모드”를 비행모드 등으로 곧장 등치*한 점. 실제 무기체계는 **안전·무장·통제 권한**이 얽힌 **운용/정비/점검/격리 모드**가 더 촘촘합니다.
* **내 의견을 바꿀 질문/추가 정보**:

  1. 대상 체계의 **플랫폼(차륜/궤도/항공/수상/잠수)**과 **버스 규격(CAN/MIL-STD-1553/이더넷/DDS)**은?
  2. **보안/인증(암호모듈, 취급등급)**로 인해 SDD에 반드시 포함해야 하는 **필수 항목**은?
  3. **데이터베이스/로그/파라미터 관리**가 존재하는가(있다면 스키마/용량/백업 요건을 반영해야 함)?

원하시는 조합을 알려주시면, 바로 해당 코드베이스에서 **SDD 초안 자동생성 파이프라인**을 짜 드리겠습니다.

[1]: https://github.com/nasa/cFS?utm_source=chatgpt.com "nasa/cFS: The Core Flight System (cFS)"
[2]: https://docs.px4.io/main/en/flight_modes?utm_source=chatgpt.com "Flight Modes | PX4 Guide (main)"
[3]: https://ardupilot.org/dev/docs/mavlink-get-set-flightmode.html?utm_source=chatgpt.com "Get and Set FlightMode — Dev documentation"
[4]: https://github.com/OpenDDS/OpenDDS?utm_source=chatgpt.com "OpenDDS is an open source C++ implementation ..."
[5]: https://github.com/OpenCyphal/libcanard?utm_source=chatgpt.com "OpenCyphal/libcanard"
[6]: https://github.com/zephyrproject-rtos/zephyr?utm_source=chatgpt.com "zephyrproject-rtos/zephyr: Primary Git Repository for the ..."
[7]: https://github.com/PX4/NuttX?utm_source=chatgpt.com "Standard NuttX with current PX4 patches"
[8]: https://github.com/gnuradio/gnuradio?utm_source=chatgpt.com "GNU Radio – the Free and Open Software Radio Ecosystem"
[9]: https://opendds.readthedocs.io/en/latest-release/devguide/introduction.html?utm_source=chatgpt.com "Introduction to OpenDDS - Read the Docs"
[10]: https://github.com/nasa/cFE?utm_source=chatgpt.com "nasa/cFE: The Core Flight System (cFS) ..."


Medical References:
1. None — DOI: file_0000000033006243820c499be9ffc293

gemini-cli를 이 대상으로 삼는다면? gemini-cli가 CSCI 등 단위로 구성되어 있고, 함수나 인터페이스 등을 명시할 수 있을까?

https://github.com/google-gemini/gemini-cli

좋아요. **gemini-cli**를 타깃 SW로 SDD Agent를 설계해도 충분히 “CSCI/CSC/CSU—인터페이스—함수/데이터요소” 수준까지 구조화가 가능합니다. 저장소 구조가 **CLI 프런트엔드(packages/cli)–Core 엔진(packages/core)–Tools(파일·검색·편집 등)**로 분해되어 있고, 텔레메트리(OTLP), 모델 API(HTTPS), GitHub Actions 연동이라는 명확한 인터페이스도 갖고 있어 SDD 자동화에 잘 맞습니다. ([GitHub][1])

---

# SDD 관점 매핑(요약)

## 4.1 CSCI/CSC/CSU 분해(제안)

* **CSCI-CLI (packages/cli)**: 명령행 진입점, 설정/인증, 플래그 파서(예: `--telemetry`, `--telemetry-otlp-endpoint`). 사용자와의 UI 경계. ([google-gemini.github.io][2])

  * **CSC: Command Runner**

    * **CSU**: 각 서브커맨드·플래그 처리기(예: 텔레메트리 관련 플래그 핸들러)
* **CSCI-Core (packages/core)**: Agent 루프, 프롬프트/컨텍스트 관리, **Tools API**와 Tool 레지스트리, 결과 요약기(summarizer). ([google-gemini.github.io][3])

  * **CSC: Tool Registry & Dispatcher**

    * **CSU**: 툴 등록/호출기, 실행 정책
  * **CSC: Prompt/Policy**

    * **CSU**: `core/prompts.ts`(시스템 프롬프트 고정 정의) ([Medium][4])
* **CSCI-Tools (packages/core/src/tools)**: 파일/검색/편집/셸 등 **환경 조작 도구** 모음. 예: `ls.ts`, `read-file.ts`, `glob.ts`, `grep.ts`, `write-file.ts`, `shell.ts`, `edit.ts`. ([Michael Esteban][5])

  * **CSC: File & Repo Tools**

    * **CSU**: `LSTool`, `ReadFileTool`, `GrepTool`, `GlobTool`, `WriteFileTool`, `ShellTool`, `EditTool`(각 도구 클래스)
* **CSCI-Telemetry**: OpenTelemetry 신호(logs/metrics/traces) 출력·전송. CLI 플래그와 env로 제어, 기본 OTLP 엔드포인트 `http://localhost:4317`. ([google-gemini.github.io][2])

  * **CSC: Exporters**

    * **CSU**: OTLP gRPC/HTTP Exporter, File exporter(관련 이슈 스레드 존재) ([GitHub][6])
* **CSCI-GitHub-Action**(선택): CI 상호작용용 러너(별도 저장소) — 조직용 배포/자동화 사례 수집에 유용. ([GitHub][7])

> 위 분해는 **첨부 SDD 양식의 4장(구성 및 상세설계) 구조**에 그대로 대응시킬 수 있습니다. 예컨대 **4.1 구성요소 식별 / 4.2 실행개념 / 5.x 상세설계** 챕터에 각 CSCI/CSC/CSU를 맵핑하고, 각 CSU에 인터페이스·데이터요소를 기술합니다. 

---

## 4.3 인터페이스(실제 표로 뽑기 쉬운 항목)

**4.3.1.1 외부 인터페이스**

* **IE-0001 “Gemini API”**: HTTPS/JSON; 인증(개인 OAuth 또는 API 키), 모델 호출 매개변수. 조직/보안정책에 맞게 IDD/ICD로 분리 가능. ([GitHub][8])
* **IE-0002 “OTLP 수집기”**: gRPC(또는 HTTP) to `OTLP_ENDPOINT`(기본 `localhost:4317`), 신호: traces/metrics/logs. 현행 CLI 플래그 표에 명시. 관련 에러/이슈도 공개되어 재현 가능. ([google-gemini.github.io][2])
* **IE-0003 “GitHub Actions 런타임/Graph API”**(선택): 이슈/PR 트리거, 레이블링 등 워크플로 제어. ([GitHub][7])

**4.3.1.2 내부 인터페이스**

* **IIC/IIP: Tool 호출 경계** – Core↔Tool 간 호출 규약(요청/응답 페이로드, 실행 컨텍스트, 요약 규칙). Tools API 및 대표 툴 목록에서 추출. ([google-gemini.github.io][3])
* **파일시스템/셸 인터페이스** – `read_file`/`write_file`/`glob`/`grep`/`shell` 등. (권한/보안·오류 처리 포함 기술)

**4.3.1.3 사용자 인터페이스**

* **CLI UI** – 명령 문법, 주요 플래그(telemetry, model 선택, 컨텍스트 파일 지정 등), 설정 파일(`~/.gemini/settings.json`) 경로. 공식 문서/플래그 표에서 자동 추출 가능. ([google-gemini.github.io][2])

> SDD 표준 양식의 **“외부/내부/사용자 인터페이스 목록·구성도 표(4.3.1.1~1.3)”** 포맷에 맞춰 ID, 연동대상, 통신방법, 프로토콜, 데이터요소를 채워 넣는 스크립트를 바로 만들 수 있습니다. 

---

## 3.x 설계결정/상태/모드(현실적 기술 범위)

* **상태/모드**: 운영 관점에서 `agent idle → plan → tool_call 실행 → summarize → respond`를 **상태도**로 정리(오류/타임아웃/거절 브랜치 포함). Core 루프/툴 디스패처 관찰로 기술. (문서화 소스: Tools API·prompts 정책) ([google-gemini.github.io][3])
* **보안/운영 결정사항**:

  * 통신(모델 API/OTLP) 채널 암호화, 자격증명 보관 위치, 셸/파일 IO 권한분리(사용자 홈 제한 등).
  * 텔레메트리 비활성/로컬 파일 출력 모드(운용 망 분리 시). 관련 플래그·이슈 근거 명시. ([google-gemini.github.io][2])

---

# 자동 추출 파이프라인(POC 설계)

1. **리포 크롤러 & AST 인게스터**

   * **대상 경로**: `packages/core/src/tools/*.ts`, `packages/core/src/core/*.ts`, `packages/cli/src/**`.
   * **방법**: ts-morph(또는 TypeScript Compiler API)로 `export class *Tool implements Tool` 등을 수집 → **CSU 목록/함수 시그니처/입출력 타입** 생성. Tools API 문서와 실제 파일명을 교차검증. ([google-gemini.github.io][3])

2. **프롬프트/정책 추출**

   * `packages/core/src/core/prompts.ts`에서 **시스템 프롬프트 블록**을 정적 파싱 → **설계결정(3.3/3.8)**에 요약 삽입. ([Medium][4])

3. **CLI 플래그·환경변수 스키마화**

   * GitHub Pages 문서의 플래그 테이블을 스크래핑/파싱 → **사용자 인터페이스 표(4.3.1.3)** 자동 생성. 텔레메트리 관련 값(기본 `http://localhost:4317`) 포함. ([google-gemini.github.io][2])

4. **인터페이스 표 자동생성(양식 매핑)**

   * 첨부 SDD 양식의 **식별자 규칙(1.3.4)**을 코드화: `IE-xxxx`, `IIC-xxxx`, `IIP-xxxx` 등 규칙에 맞춰 외부/내부/사용자 인터페이스에 **ID 자동부여**. 
   * **출력물**: `external_interfaces.csv`, `internal_interfaces.csv`, `ui_interfaces.csv` + `plantuml`/`mermaid` 다이어그램.

5. **요구–설계–코드 추적(초판)**

   * 요구사항 대신 **설계결정/정책 항목**을 “요구 유사 ID”로 부여하고, 해당 결정을 **코드 위치(파일/클래스/함수)**와 링크 → **추적표(6장) 초안** 생성.

> 모든 표/도면은 **첨부 SDD 양식의 표/식별자 규칙**(예: `IE-0000`, `IIC-0000` 등)에 맞춰 산출하도록 스키마를 설계합니다.

---

## “함수/인터페이스를 명시할 수 있나?”에 대한 결론

* **함수(단위 설계)**: Tools 클래스들(예: `ReadFileTool.execute(input): Output`)은 **입력·출력·부작용(IO)**가 명확해 **5장 CSU 상세설계**로 기술하기 좋습니다. Tools API 문서/구현 파일에서 시그니처를 기계적으로 추출할 수 있습니다. ([google-gemini.github.io][3])
* **인터페이스**:

  1. **모델 API(HTTPS)**,
  2. **OTLP 수집기(gRPC/HTTP)**,
  3. **로컬 FS/셸 IO**,
  4. (선택) **GitHub Actions 런타임** — 모두 **연동대상/통신방법/프로토콜/데이터요소**까지 테이블화 가능합니다(4.3.1 표 형식). ([google-gemini.github.io][2])

---

## 바로 적용 가능한 산출물(샘플 컬럼 설계)

* `external_interfaces.csv` → `식별자, 연동기능, 연동대상, 통신방법, 운용성수준, 프로토콜, 데이터요소`(양식 표27과 호환). 
* `internal_interfaces.csv` → `식별자, 연동기능, 연동대상(CSC/CSU), 통신방법(IIC), 프로토콜(IIP), 데이터요소`. 
* `ui_interfaces.csv` → `식별자, 장비명(터미널), 기능명, 주사용자, 인터페이스방법(커맨드/플래그), 인터페이스요소(필수/옵션)`. 

원하시면 위 파이프라인의 **초판 스크립트(리포 파서 + CSV/MD 템플릿 + PlantUML)**를 바로 만들어 드릴게요.

---

# 불확실성 지도

* **가장 덜 자신있는 부분**: gemini-cli 내부의 “에이전트 루프”가 명시적 상태머신으로 고정되어 있는지 여부(코드의 리팩터링 주기상 구조가 바뀔 수 있음). 해당 부분은 최신 커밋 기준으로 재확인이 필요합니다.
* **지나치게 단순화했을 수 있는 부분**: “CSCI-Telemetry”를 별도 CSCI로 분리한 점. 실제 배포 구성에서는 Core의 하위 CSC로 보는 편이 더 자연스러울 수 있습니다.
* **내 의견을 바꿀 질문/추가 정보**:

  1. 본 SDD에서 **GitHub Actions 연동**을 포함할지(포함 시 외부 인터페이스·운용 시나리오가 확장됨).
  2. **망 분리/보안 등급**으로 인해 OTLP/모델 API 사용 방식(차단/프록시/파일출력 대체)을 어떻게 기술해야 하는지.
  3. SDD 5장 상세설계 수준에서 **어느 레벨까지 함수 시그니처·예외·로깅 필드를 요구**하는지(필요하면 AST 기반으로 더 깊게 뽑아 확장 가능).

[1]: https://github.com/google-gemini/gemini-cli?utm_source=chatgpt.com "google-gemini/gemini-cli: An open-source AI agent ..."
[2]: https://google-gemini.github.io/gemini-cli/docs/telemetry.html?utm_source=chatgpt.com "Observability with OpenTelemetry | gemini-cli - GitHub Pages"
[3]: https://google-gemini.github.io/gemini-cli/docs/core/tools-api.html?utm_source=chatgpt.com "Gemini CLI Core: Tools API - GitHub Pages"
[4]: https://medium.com/google-cloud/practical-gemini-cli-tool-calling-52257edb3f8f?utm_source=chatgpt.com "Practical Gemini CLI: Tool calling - Google Cloud"
[5]: https://mikeesto.com/posts/uncovering-gemini-cli/?utm_source=chatgpt.com "Uncovering Gemini CLI"
[6]: https://github.com/google-gemini/gemini-cli/issues/5063?utm_source=chatgpt.com "Telemetry file export requires explicit empty OTLP endpoint"
[7]: https://github.com/google-github-actions/run-gemini-cli?utm_source=chatgpt.com "google-github-actions/run-gemini-cli"
[8]: https://github.com/google-gemini?utm_source=chatgpt.com "google-gemini"


Medical References:
1. None — DOI: file_0000000033006243820c499be9ffc293